# QnA AI 플랫폼 개발 과정

## 프로젝트 개요

### 초기 요구사항
사용자가 질문을 하고 그에 대해 답변을 해주는 지식 공유 플랫폼을 만들되, 무조건 사람이 답변하는 것이 아닌 **기존 질의응답 데이터를 활용하여 AI도 응답을 해주는 서비스**를 구축하고자 함.

### 참고 페이지
인프런 커뮤니티 구조를 참고:
- https://www.inflearn.com/community/questions/1760337/connection-lost-%EA%B0%80-%EC%95%88-%EC%97%86%EC%96%B4%EC%A7%80%EB%84%A4%EC%9A%94-%E3%85%9C-%E3%85%9C

### 핵심 요구사항
- 질문과 답변을 따로 작성하는 것이 아닌 **댓글 형식**
- 질문 조회 시 모든 답변(댓글)도 함께 반환
- 답변 작성 API: `POST /api/questions/{id}/answers`
- AI 자동 답변: 질문 등록 즉시 첫 댓글로 자동 생성

---

## 기술 스택 선택 과정

### 1. 데이터베이스 선택
**선택**: MySQL/MariaDB
- 이유: 관계형 DB로 안정적이고 널리 사용됨

### 2. AI 방식 선택
**선택**: RAG (Retrieval-Augmented Generation)
- 기존 Q&A를 검색하여 컨텍스트로 활용
- 더 정확한 답변 가능

### 3. 벡터 데이터베이스 선택
**선택**: ChromaDB
- Spring AI 공식 지원
- Docker로 간단하게 설정 가능
- 로컬 개발에 적합

### 4. 임베딩 모델 선택
**선택**: Ollama 임베딩 모델 (all-minilm)
- 현재 RunPod 서버 활용 가능
- 일관된 인프라

### 5. 초기 데이터
**선택**: 샘플 데이터로 시작
- 3개의 샘플 Q&A 제공
- 나중에 실제 데이터 추가 가능

---

## 아키텍처 설계

```
User Request → QuestionController
    ↓
RagService (핵심 RAG 로직)
    ├── VectorStoreService → ChromaDB (유사 Q&A 검색)
    ├── EmbeddingService → Ollama Embedding (임베딩 생성)
    └── ChatClient → Ollama LLM (답변 생성)
    ↓
QuestionService/AnswerService → MySQL
```

---

## 구현 과정

### Phase 1: 기본 인프라 설정

#### 1.1 의존성 추가 (build.gradle)
```gradle
dependencies {
    // 기존
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.ai:spring-ai-ollama-spring-boot-starter'

    // 추가
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.mysql:mysql-connector-j'
    implementation 'org.springframework.ai:spring-ai-chroma-store-spring-boot-starter'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
}
```

#### 1.2 Docker Compose 설정
- MySQL 8.0 컨테이너
- ChromaDB 컨테이너
- 영구 볼륨 설정

#### 1.3 application.properties 설정
- MySQL 연결 설정
- Ollama 설정 (RunPod 서버)
- ChromaDB 설정
- 샘플 데이터 자동 로드

#### 1.4 Entity 생성
**Question** (인프런 구조 참고):
- id, title, content, userName
- viewCount, upvoteCount (추천 기능)
- createdAt, updatedAt

**Answer** (댓글 형식):
- id, questionId (FK)
- content, userName
- aiGenerated (AI 생성 여부)
- accepted (채택 여부)
- upvoteCount
- createdAt, updatedAt

**QaEmbeddingMetadata**:
- questionId, answerId
- vectorStoreId (ChromaDB 매핑)

#### 1.5 Repository 인터페이스
- QuestionRepository
- AnswerRepository
- QaEmbeddingMetadataRepository

---

### Phase 2: 벡터 스토어 설정

#### Spring Boot Auto-configuration 사용
- Spring AI 1.0.0-M5의 Auto-configuration 활용
- `application.properties` 설정만으로 Bean 자동 생성:
  - `spring.ai.ollama.embedding.model` → OllamaEmbeddingModel Bean
  - `spring.ai.ollama.chat.model` → ChatClient Bean
  - `spring.ai.vectorstore.chroma.*` → ChromaDB VectorStore Bean
- 별도의 Configuration 클래스 불필요

---

### Phase 3: 서비스 레이어 구현

#### 3.1 기본 서비스
**QuestionService**:
- create(): 질문 생성
- findById(), findAll(): 조회
- searchByKeyword(): 검색
- incrementViewCount(): 조회수 증가
- incrementUpvoteCount(): 추천

**AnswerService**:
- create(): 답변 생성
- findByQuestionId(): 특정 질문의 답변 목록
- incrementUpvoteCount(): 답변 추천
- markAsAccepted(): 답변 채택

#### 3.2 VectorStoreService
- findSimilarQA(): 유사 Q&A 검색
- buildContextFromDocuments(): 컨텍스트 구성

#### 3.3 EmbeddingService
- createQaEmbedding(): Q&A 페어 임베딩 생성
- deleteQaEmbedding(): 임베딩 삭제

#### 3.4 RagService ⭐ **핵심**
RAG 워크플로우:
1. 질문으로 유사 Q&A 검색 (상위 3개)
2. 검색 결과를 컨텍스트로 구성
3. 시스템 프롬프트 + 컨텍스트 + 질문 조합
4. Ollama LLM 호출하여 답변 생성
5. 답변 저장 (aiGenerated=true, userName="AI 인턴")
6. 새로운 Q&A 페어 임베딩 생성

---

### Phase 4: REST API 구현

#### DTO 클래스
- QuestionRequest/Response
- AnswerRequest/Response

#### QuestionController 엔드포인트
1. `POST /api/questions` - 질문 생성 + AI 자동 답변
2. `GET /api/questions` - 질문 목록 조회
3. `GET /api/questions/{id}` - 특정 질문 조회 (답변 포함)
4. `GET /api/questions/search?keyword=` - 키워드 검색
5. `POST /api/questions/{id}/answers` - 답변 추가 (댓글)
6. `POST /api/questions/{id}/upvote` - 질문 추천
7. `POST /api/questions/answers/{answerId}/upvote` - 답변 추천
8. `POST /api/questions/answers/{answerId}/accept` - 답변 채택

#### 예외 처리
- GlobalExceptionHandler
- ResourceNotFoundException

---

### Phase 5: 샘플 데이터 및 초기화

#### data.sql
3개의 샘플 Q&A:
1. Spring Boot JPA 설정 방법
2. Docker Compose MySQL 실행
3. RAG 개념 설명

#### DataInitializer
- CommandLineRunner로 애플리케이션 시작 시
- 기존 Q&A에 대한 임베딩 자동 생성

---

## 데이터베이스 스키마

### question 테이블
```sql
CREATE TABLE question (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_name VARCHAR(100),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    view_count INT DEFAULT 0,
    upvote_count INT DEFAULT 0
);
```

### answer 테이블
```sql
CREATE TABLE answer (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    question_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    is_ai_generated BOOLEAN DEFAULT FALSE,
    is_accepted BOOLEAN DEFAULT FALSE,
    similarity_score DOUBLE,
    user_name VARCHAR(100),
    upvote_count INT DEFAULT 0,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    FOREIGN KEY (question_id) REFERENCES question(id)
);
```

### qa_embedding_metadata 테이블
```sql
CREATE TABLE qa_embedding_metadata (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    question_id BIGINT NOT NULL,
    answer_id BIGINT NOT NULL,
    vector_store_id VARCHAR(255) UNIQUE,
    embedding_created_at TIMESTAMP,
    FOREIGN KEY (question_id) REFERENCES question(id),
    FOREIGN KEY (answer_id) REFERENCES answer(id)
);
```

---

## RAG 워크플로우 상세

```
1. 사용자 질문 입력 (POST /api/questions)
   ↓
2. QuestionService.create() → MySQL 저장
   ↓
3. RagService.generateAnswer() 호출
   ↓
4. VectorStoreService.findSimilarQA()
   - 질문 텍스트 임베딩 (자동)
   - ChromaDB 벡터 유사도 검색 (cosine similarity)
   - 상위 3개 유사 Q&A 반환
   ↓
5. VectorStoreService.buildContextFromDocuments()
   - 검색된 Document들을 프롬프트용 텍스트로 변환
   ↓
6. ChatClient.prompt()
   - System: "당신은 친절한 기술 지원 전문가입니다..."
   - User: "참고 자료: {context}\n질문: {question}"
   - Ollama gemma3:4b 호출
   ↓
7. AI 응답 받기 → Answer 엔티티 생성
   - isAiGenerated=true
   - userName="AI 인턴"
   ↓
8. AnswerService.save() → MySQL 저장
   ↓
9. EmbeddingService.createQaEmbedding()
   - 새로운 Q&A 페어 텍스트 생성
   - Ollama embedding 모델로 벡터 생성
   - ChromaDB에 Document 추가
   - QaEmbeddingMetadata에 매핑 저장
   ↓
10. QuestionResponse 반환 (질문 + AI 답변 포함)
```

---

## 프로젝트 구조

```
src/main/java/kr/yonggeon/qnaai/
├── config/
│   └── DataInitializer.java         # 초기 임베딩 생성
├── controller/
│   └── QuestionController.java      # REST API
├── dto/
│   ├── QuestionRequest.java
│   ├── QuestionResponse.java
│   ├── AnswerRequest.java
│   └── AnswerResponse.java
├── entity/
│   ├── Question.java                # 질문 엔티티
│   ├── Answer.java                  # 답변 엔티티 (댓글)
│   └── QaEmbeddingMetadata.java     # 임베딩 메타데이터
├── exception/
│   ├── GlobalExceptionHandler.java
│   └── ResourceNotFoundException.java
├── repository/
│   ├── QuestionRepository.java
│   ├── AnswerRepository.java
│   └── QaEmbeddingMetadataRepository.java
├── service/
│   ├── QuestionService.java         # 질문 CRUD
│   ├── AnswerService.java           # 답변 CRUD
│   ├── VectorStoreService.java      # 벡터 검색
│   ├── EmbeddingService.java        # 임베딩 생성
│   └── RagService.java              # ⭐ RAG 핵심 로직
└── QnaAiApplication.java

src/main/resources/
├── application.properties
└── db/
    └── data.sql                      # 샘플 데이터

docker-compose.yml                    # MySQL, ChromaDB 컨테이너
build.gradle                          # 의존성 설정
README.md                             # 사용 가이드
```

---

## 핵심 기능 설명

### 1. 댓글 형식 Q&A
- 하나의 질문(Question)에 여러 답변(Answer) 1:N 관계
- 질문 조회 시 모든 답변이 함께 반환됨
- 인프런 커뮤니티 구조와 동일

### 2. AI 자동 답변
- 질문 등록 즉시 RagService가 AI 답변 생성
- "AI 인턴"이라는 이름으로 첫 댓글 자동 작성
- aiGenerated 플래그로 AI/사람 구분

### 3. RAG 시스템
- 유사한 기존 Q&A를 ChromaDB에서 검색
- 검색 결과를 컨텍스트로 LLM에 제공
- 더 정확하고 관련성 높은 답변 생성

### 4. 추천 시스템
- 질문과 답변 모두 upvote 가능
- 인기 있는 질문/답변 파악 가능

### 5. 답변 채택
- 질문자가 도움이 된 답변을 채택
- accepted 플래그로 표시

---

## 사용 예시

### 1. 질문 생성 (AI 답변 자동 생성)
```bash
curl -X POST http://localhost:8080/api/questions \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Spring Security 설정 방법",
    "content": "Spring Boot 3.x에서 Spring Security를 설정하려면?",
    "userName": "개발자G"
  }'
```

**응답**:
```json
{
  "id": 4,
  "title": "Spring Security 설정 방법",
  "content": "Spring Boot 3.x에서...",
  "userName": "개발자G",
  "viewCount": 0,
  "upvoteCount": 0,
  "createdAt": "2026-02-01T17:00:00",
  "answerCount": 1,
  "answers": [
    {
      "id": 10,
      "content": "Spring Security 3.x에서는...",
      "userName": "AI 인턴",
      "aiGenerated": true,
      "accepted": false,
      "upvoteCount": 0,
      "createdAt": "2026-02-01T17:00:01"
    }
  ]
}
```

### 2. 사람이 추가 답변 작성 (댓글)
```bash
curl -X POST http://localhost:8080/api/questions/4/answers \
  -H "Content-Type: application/json" \
  -d '{
    "content": "추가로 설명하자면...",
    "userName": "전문가H"
  }'
```

### 3. 질문 조회 (모든 댓글 포함)
```bash
curl http://localhost:8080/api/questions/4
```

**응답**: 질문 + AI 답변 + 사람 답변 모두 포함

---

## 주요 설정

### application.properties
```properties
# MySQL
spring.datasource.url=jdbc:mysql://localhost:3306/qna_db
spring.datasource.username=root
spring.datasource.password=qna_password
spring.jpa.hibernate.ddl-auto=update

# Ollama (RunPod)
spring.ai.ollama.base-url=https://5vosd1iqsrzrch-11434.proxy.runpod.net/
spring.ai.ollama.chat.model=gemma3:4b
spring.ai.ollama.embedding.model=all-minilm

# ChromaDB
spring.ai.vectorstore.chroma.client.host=localhost
spring.ai.vectorstore.chroma.client.port=8000
spring.ai.vectorstore.chroma.collection-name=qna_embeddings

# 샘플 데이터 자동 로드
spring.sql.init.mode=always
spring.sql.init.data-locations=classpath:db/data.sql
spring.jpa.defer-datasource-initialization=true
```

---

## 향후 확장 가능성

### 단기
- 사용자 인증/권한 (Spring Security)
- 태그 시스템
- 페이지네이션
- 답변 수정/삭제 기능

### 중기
- 실시간 채팅 (WebSocket)
- 이미지 첨부
- 전문 검색 (Elasticsearch)
- 다중 언어 지원

### 장기
- Milvus로 벡터 DB 마이그레이션
- 마이크로서비스 아키텍처
- 사용자 맞춤형 추천
- A/B 테스팅

---

## 결론

성공적으로 RAG 기반 질의응답 플랫폼을 구축했습니다:
- ✅ 인프런 스타일 댓글 형식 Q&A
- ✅ AI 자동 답변 (질문 등록 즉시)
- ✅ RAG로 기존 데이터 활용
- ✅ 추천, 채택 등 커뮤니티 기능
- ✅ RESTful API 완비
- ✅ Docker 기반 인프라

모든 핵심 기능이 구현되었으며, 확장 가능한 아키텍처로 설계되었습니다.
